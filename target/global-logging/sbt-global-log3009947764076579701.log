[0m[[0m[0mdebug[0m] [0m[0m> Exec(__stopWatch network-2, None, None)[0m[0J
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/raraza/url-shortner/src/main/scala/org/raraza/services/ShortCodeService.scala","languageId":"scala","version":1,"text":"package org.raraza.services\r\n\r\nimport org.raraza.util._\r\nimport scala.concurrent.ExecutionContext.Implicits.global\r\nimport scala.concurrent.Future\r\n\r\ntrait ShortCodeService {\r\n  def create(url: String): Future[String]\r\n}\r\n\r\nclass DefaultShortCodeService extends ShortCodeService {\r\n\r\n  override def create(url: String): Future[String] = {\r\n    Future {\r\n      val md5Bytes = md5(url)\r\n\r\n      val byteArr = md5Bytes.slice(12, 16)\r\n\r\n      val builder = new StringBuilder()\r\n      byteArr.foreach { r =>\r\n        val bytes = Array(r)\r\n        isValidUTF8(bytes) match {\r\n          case Some(charBuffer) => builder.append(charBuffer)\r\n          case None => builder.append(\"\\\\x%02X \".format(r))\r\n        }\r\n      }\r\n\r\n      val utf8Str = builder.toString().replaceAll(\" \", \"\")\r\n      base64(utf8Str).dropRight(2)\r\n    }\r\n  }\r\n}\r\n"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/raraza/url-shortner/src/test/scala/org/raraza/UrlShortenerRoutePostSpec.scala","languageId":"scala","version":1,"text":"package org.raraza\n\nimport akka.actor.ActorSystem\nimport akka.http.scaladsl.model.{ FormData, HttpHeader }\nimport akka.http.scaladsl.model.StatusCodes._\nimport org.raraza.models._\nimport scala.concurrent.Future\n\nclass UrlShortenerRoutePostSpec extends SpecBase {\n\n  def actorRefFactory: ActorSystem = system\n\n  val baseAddress = \"http://example.com\"\n\n  \"Shortener Api\" should {\n    \"shorten valid url if not exist\" in {\n      val expectedShortCode: String = \"6a6q6\"\n      val urlToShorten = \"http://www.dice.se/games/star-wars-battlefront/\"\n      val urlShortenRequest = UrlShortenRequest(url = urlToShorten)\n      val urlShortenResult = UrlShortenResult(code = expectedShortCode, status = EntityOperations.EntityCreated)\n\n      urlShortenerServiceMock.shorten(urlShortenRequest) returns Future(urlShortenResult)\n\n      Post(\"/\", FormData(\"url\" -> urlToShorten).toEntity) ~> router.routes ~> check {\n        handled shouldEqual true\n        status shouldEqual Created\n\n        val location: Option[HttpHeader] = header(\"Location\")\n        location.get.value() shouldEqual s\"$baseAddress/$expectedShortCode\"\n      }\n    }\n\n    \"reply with `BadRequest` when invalid url posted\" in {\n      val urlToShorten = \"httx:#/?!@_www.dice.se~/ga/\"\n\n      Post(\"/\", FormData(\"url\" -> urlToShorten).toEntity) ~> router.routes ~> check {\n        handled shouldEqual true\n        status shouldEqual BadRequest\n      }\n    }\n\n    \"return same shortened url when same url posted\" in {\n      val expectedShortCode: String = \"6a6q6\"\n      val urlToShorten = \"http://www.dice.se/games/star-wars-battlefront/\"\n      val urlShortenRequest = UrlShortenRequest(url = urlToShorten)\n      val urlShortenResult = UrlShortenResult(code = expectedShortCode, status = EntityOperations.EntityFound)\n\n      urlShortenerServiceMock.shorten(urlShortenRequest) returns Future(urlShortenResult)\n\n      Post(\"/\", FormData(\"url\" -> urlToShorten).toEntity) ~> router.routes ~> check {\n        handled shouldEqual true\n        status shouldEqual Found\n\n        val location: Option[HttpHeader] = header(\"Location\")\n        location.get.value() shouldEqual s\"$baseAddress/$expectedShortCode\"\n      }\n    }\n\n    \"return `badRequest` if URL shortening operation failed\" in {\n      val urlToShorten = \"http://www.dice.se/games/star-wars-battlefront/\"\n      val urlShortenRequest = UrlShortenRequest(url = urlToShorten)\n      val urlShortenResult = UrlShortenResult(\"\", status = EntityOperations.OperationFailed)\n\n      urlShortenerServiceMock.shorten(urlShortenRequest) returns Future(urlShortenResult)\n\n      Post(\"/\", FormData(\"url\" -> urlToShorten).toEntity) ~> router.routes ~> check {\n        handled shouldEqual true\n        status shouldEqual BadRequest\n      }\n    }\n  }\n}\n"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/raraza/url-shortner/src/main/scala/org/raraza/services/UrlShortenerService.scala","languageId":"scala","version":1,"text":"package org.raraza.services\n\nimport com.typesafe.scalalogging.LazyLogging\nimport org.raraza.models.{ EntityOperations, Stats, UrlShortenRequest, UrlShortenResult }\nimport org.raraza.persistence.DataStore\nimport org.raraza.util.KeyUtils.{ codeAsKey, urlAsKey, urlAsStatsKey }\nimport org.raraza.util.urlSafeEncode64\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\nimport scala.language.postfixOps\n\ntrait UrlShortenerService {\n  def shorten(request: UrlShortenRequest): Future[UrlShortenResult]\n\n  def get(code: String): Future[Option[String]]\n\n  def stats(url: String): Future[Option[Stats]]\n\n  def clean(url: String): Future[Boolean]\n}\n\nclass DefaultUrlShortenerService(\n  val dataStore: DataStore,\n  val shortCodeService: ShortCodeService,\n  val statsService: StatsService)\n  extends UrlShortenerService with LazyLogging {\n\n  override def shorten(request: UrlShortenRequest): Future[UrlShortenResult] = {\n    logger.debug(s\"Creating shortened URL for: ${request.url}\")\n\n    for {\n      codeOpt <- getByUrl(request.url)\n      result <- codeOpt match {\n        case Some(code) =>\n          logger.debug(s\"The requested URL(${request.url}) is already shortened, so will return found one.\")\n          Future.successful(UrlShortenResult(code, status = EntityOperations.EntityFound))\n        case None => save(request.url)\n      }\n    } yield result\n  }\n\n  override def get(code: String): Future[Option[String]] = {\n\n    logger.debug(s\"Access requested for shortened URL using code: $code\")\n\n    (for {\n      exists <- dataStore.exists(codeAsKey(code))\n      _ <- predicate(exists)(new Exception(\"Key not found in data store\"))\n      result <- dataStore.get[String](codeAsKey(code))\n      _ <- result match {\n        case Some(url) => statsService.hit(urlAsStatsKey(urlSafeEncode64(url)))\n        case None => Future(())\n      }\n    } yield result).recover({\n      case ex: Exception =>\n        logger.error(s\"An error occurred while getting URL by given code:$code\", ex)\n        None\n    })\n  }\n\n  override def stats(url: String): Future[Option[Stats]] = {\n    statsService.getStats(urlAsStatsKey(urlSafeEncode64(url))) map {\n      statsOpt: Option[Long] =>\n        statsOpt match {\n          case Some(callCount) => Some(Stats(callCount))\n          case None => None\n        }\n    }\n  }\n\n  override def clean(url: String): Future[Boolean] = {\n    for {\n      urlOpt: Option[String] <- dataStore.get[String](urlAsKey(urlSafeEncode64(url)))\n      result <- urlOpt match {\n        case Some(code) => purge(code, url)\n        case _ =>\n          logger.debug(s\"There is no record to clean for requested URL($url)\")\n          Future(false)\n      }\n    } yield result\n  }\n\n  private def save(url: String): Future[UrlShortenResult] = (\n    // TODO: Collision handling\n\n    for {\n      code <- shortCodeService.create(url)\n      _ <- dataStore.save[String](codeAsKey(code), url)\n      _ <- dataStore.save[String](urlAsKey(urlSafeEncode64(url)), code)\n    } yield UrlShortenResult(code, status = EntityOperations.EntityCreated)).recover({\n      case ex: Throwable =>\n        logger.error(\"An error occurred while saving shortened url record.\", ex)\n        UrlShortenResult(\"\", status = EntityOperations.OperationFailed)\n    })\n\n  private def purge(code: String, url: String): Future[Boolean] = {\n    logger.debug(s\"All records will be purged for URL($url)\")\n    (for {\n      _ <- dataStore.delete(codeAsKey(code))\n      _ <- dataStore.delete(urlAsKey(urlSafeEncode64(url)))\n      _ <- dataStore.delete(urlAsStatsKey(urlSafeEncode64(url)))\n    } yield true).recover({\n      case _: Throwable => false\n    })\n  }\n\n  private def predicate(condition: Boolean)(fail: Exception): Future[Unit] =\n    if (condition) Future(()) else Future.failed(fail)\n\n  private def getByUrl(url: String): Future[Option[String]] = dataStore.get[String](urlAsKey(urlSafeEncode64(url)))\n}\n"}})[0m[0J
